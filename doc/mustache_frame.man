[comment {-*- tcl -*- doctools manpage}]
[include parts/definitions.inc]
[vset VERSION 1]
[manpage_begin [vset LABEL_FRAME] [vset MAN_SECTION] [vset VERSION]]
[include parts/module.inc]
[require mustache::frame]
[keywords {data frame} {typed value} value]
[titledesc [vset TITLE_FRAME]]
[description]
[include parts/welcome.inc]

[section Overview]

[package mustache::context] objects make use of [term {data frame}]
objects to hold the values they will hand to the
[cmd {mustache render}] command while it renders a template.

[para] [package mustache::frame] provides seven TclOO classes for
holding scalar values of various types, sequences, and mappings, all
suitable for working with the objects provided by the
[package mustache::context] package.

[para] Note however that [emph any] command prefix supporting the
[sectref {Instance API}] below will be suitable for working with the
same.

[para] This is not necessarily true for custom context objects. Such
may have their own API for working with typed values.

[section {Class API}]

[list_begin definitions]
[comment {- - -- --- ----- -------- -------------}]
[call [cmd {::mustache frame fromTags}] [arg spec]]

Converts the tagged nested data structure in [arg spec], representing
a hierarchy of mappings, sequences, and scalar values, into an
equivalent hierarchy of data frame objects.

[para] Returns the root object of the generated data frame hierarchy.

[para] The [arg spec] has to be a 2-element list of tag and value, in
this order. The accepted tags and the associated values are

[list_begin definitions]
[def [const bool]]

	The value is a boolean.

[def [const float]]

	The value is a floating point number.

[def [const int]]

	The value is an integer number.

[def [const null]]

	The value is null/nil/missing.

[def [const scalar]]
[def [const string]]

	The value is an arbitrary string.
	Internally it is mapped to [type string!] frames.

[def [const sequence]]

	The value is a Tcl list containing nested specs.

[def [const mapping]]

	The value is a Tcl dictionary whose keys and values are nested
	specs. Note however that it is expected that keys are always
	tagged as scalars.

[list_end]

[para][strong Note] that the [package [vset tclyaml/core]] package is
able to generate this type of tagged structure.

[para][strong Note] further that the type-specific tags are only
generated by [vset tclyaml/core] version 0.5 and up. Version 0.4 and
before generate only the un-typed [const scalar] tag.

[para] Example:
[example {
mapping {
	{scalar FIELD} {scalar VAL}
	{scalar SEQ} {sequence {
		{scalar 1}
		{scalar 2}
		{scalar 3}
	}}
	{scalar SUB} {mapping {
		{scalar CHILD} {scalar X}
	}}
}
}]

[comment {- - -- --- ----- -------- -------------}]
[call [cmd {::mustache frame bool}] [method create] [arg obj] [arg value]]
[call [cmd {::mustache frame bool}] [method new] [arg value]]

[call [cmd {::mustache frame float}] [method create] [arg obj] [arg value]]
[call [cmd {::mustache frame float}] [method new] [arg value]]

[call [cmd {::mustache frame int}] [method create] [arg obj] [arg value]]
[call [cmd {::mustache frame int}] [method new] [arg value]]

[call [cmd {::mustache frame null}] [method create] [arg obj] [opt [arg value]]]
[call [cmd {::mustache frame null}] [method new] [opt [arg value]]]

[call [cmd {::mustache frame scalar}] [method create] [arg obj] [arg value]]
[call [cmd {::mustache frame scalar}] [method new] [arg value]]

[call [cmd {::mustache frame string}] [method create] [arg obj] [arg value]]
[call [cmd {::mustache frame string}] [method new] [arg value]]

[call [cmd {::mustache frame string!}] [method create] [arg obj] [arg value]]
[call [cmd {::mustache frame string!}] [method new] [arg value]]

These constructor commands create a new [term scalar] data frame of
the given type, initialize it using the [arg value] and return the
fully qualified name of that instance.

[para] [strong ATTENTION]

Of these three, best use [const string!] over all else.

[para]

[strong {Do not use}] [type string]. While the disrecommended type is
the original type for string values it is now present only to pass the
mustache compatibility tests. It comes with auto-magic behaviour
counter to what is expected from a string type, i.e. to pass all
values as they are.

[para]

[type string] does not do that. Any value which looks like a number it
"normalizes".

[para]

The new type [type string!] on the other hand does exactly that. No
auto-magic normalization, i.e. mangling of things looking like
numbers. Just passing values as they are.

[comment {- - -- --- ----- -------- -------------}]
[call [cmd {::mustache frame sequence}] [method create] [arg obj] [arg value]]
[call [cmd {::mustache frame sequence}] [method new] [arg value]]

These constructor commands create a new [term sequence] data frame,
initialize it using the [arg value] and return the fully qualified
name of that instance.

[para] The [arg value] has to be a list of data frame objects.

[para][strong Attention:] The new sequence takes over ownership of the
data frames in the list, and they will be destroyed when the sequence
is destroyed.

[comment {- - -- --- ----- -------- -------------}]
[call [cmd {::mustache frame mapping}] [method create] [arg obj] [arg value]]
[call [cmd {::mustache frame mapping}] [method new] [arg value]]

These constructor commands create a new [term mapping] data frame,
initialize it using the [arg value] and return the fully qualified
name of that instance.

[para] The [arg value] has to be a dictionary mapping arbitrary
strings to data frames. The keys of the dictionary name the fields
which can be found in the mapping later on, and the data frames hold
the associated values.

[para][strong Attention:] The new mapping takes over ownership of the
data frames in the dictionary, and they will be destroyed when the
mapping is destroyed.

[list_end]

[section {Instance API}]

[para] Data frames are what the context uses as containers for typed
values. It should be noted that it actually does not care about the
specific type of a value, only about the behaviour it supports, which
can be queried (See the methods [method nil?] and [method iterable?]).

[list_begin definitions]
[comment {- - -- --- ----- -------- -------------}]
[call [method frameCmd] [cmd type]]

Returns the type of the frame.

[comment {- - -- --- ----- -------- -------------}]
[call [method frameCmd] [cmd is] [arg type]]

Checks if the frame is of the specified [arg type] and returns the
result as a boolean value.

[comment {- - -- --- ----- -------- -------------}]
[call [method frameCmd] [cmd has?] [arg field]]

Checks if the value has the named [arg field].

[para] Returns a boolean value indicating either success
([const true]) or failure ([const false]) of the search.

[para] Note that scalars and sequences do not have fields. Searching
them always fails.

[comment {- - -- --- ----- -------- -------------}]
[call [method frameCmd] [cmd field] [arg field]]

Returns the data frame for the named [arg field].

[para] Scalars and sequences throw an error, as they do not have
fields. A mapping will throw an error only if the named [arg field]
is not known.

[comment {- - -- --- ----- -------- -------------}]
[call [method frameCmd] [cmd iter] [arg context] [arg script]]

Iterates over the elements of the frame and invokes the [arg script]
for each of them.

During the execution of the [arg script] the active element will be
pushed into the [arg context], and popped again after.

[para] Returns the empty string.

[para] Scalars and mappings will throw an error, as they cannot be
iterated over.

[comment {- - -- --- ----- -------- -------------}]
[call [method frameCmd] [cmd iterable?]]

Asks the frame if it can be iterated over. In other words, if it is a
non-empty sequence of values.

[para] Returns a boolean value. [const true] signals that the frame
can be iterated over.

[para] Scalars and mappings always return [const false]. Sequences
return [const false] only if they are mpty.

[comment {- - -- --- ----- -------- -------------}]
[call [method frameCmd] [cmd nil?]]

Asks the frame if it is nil, false, empty, etc.

[para] Returns a boolean value. [const true] signals that the frame's
value is indeed nil, empty, false, etc.

[para] Strings are nil if they are either the empty string, or their
value can be interpreted as a boolean value, and is representing
[const false].

[para] Numbers are never nil, nulls are always nil, and booleans are
nil if they represent [const false].

[para] Sequences and mappings are nil if they are empty, i.e of length
or size [const 0].

[comment {- - -- --- ----- -------- -------------}]
[call [method frameCmd] [cmd value]]

Returns the Tcl string value of the frame. Supported by all types.

[para] Sequences and mappings return Tcl stringifications of their
list or dictionary, respectively. This will recurse through nested
structures.

[comment {- - -- --- ----- -------- -------------}]
[call [method frameCmd] [cmd as] [arg type]]

Returns the string representation of the data frame as per the
specified [arg type].

[para] It is expected that the [arg type] is backed by a package named
[package ::mustache::frame::as::<[arg type]>], exporting a command of
the same name.

[para] This command has to be suitable for use with the data frame's
[method visit] method.

The [method as] method will invoke [method visit] with the type
command to perform the actual conversion.

[comment {- - -- --- ----- -------- -------------}]
[call [method frameCmd] [cmd visit] [opt [arg word]...]]

This method visits the data frame and its children in interleaved
pre- and post-order, invoking the command prefix specified by the
[arg word]... for each frame once (scalars) or twice (sequences, and
mappings).

[para] The result of the method is the result of the last invokation
of the command prefix for the top data frame.

[para]The command prefix is always called in the global scope. It is
expected to support the signatures below. The [arg frame] argument is
always the object command of the data frame the call is for.

[list_begin definitions]
[call [method "{*}word..."] [arg type] [arg frame] [arg value]]

Called for all scalar frames, once. The [arg value] is the Tcl value
of the scalar. The [arg type] is one of the possible scalar type tags.

[call [method "{*}word..."] [method {sequence start}] [arg frame]]

Called at the beginning of a sequence, enables initializations in the
converter.  The return value, if any, is ignored.

[call [method "{*}word..."] [method {sequence exit}] [arg frame] [arg value]]

Called after visiting the children of a sequence. The [arg value] is a
list containing the results of visiting the sequence's elements.

[call [method "{*}word..."] [method {mapping start}] [arg frame]]

Called at the beginning of a mapping, enables initializations in the
converter.  The return value, if any, is ignored.

[call [method "{*}word..."] [method {mapping exit}] [arg frame] [arg value]]

Called after visiting the value children of a mapping. The [arg value]
is a dictionary mapping the field names to the results of visiting
their frames.

[list_end][comment {-- command prefix signatures}]

[list_end][comment {-- main command list}]


[section {Scalar Instance API}]

[para] Scalar data frames provide more than just the generic API.
These additional methods should only be used after a type check:

[list_begin definitions]
[comment {- - -- --- ----- -------- -------------}]
[call [method scalarCmd] [cmd set] [arg value]]

Set the new scalar [arg value] into the frame.

An error will be thrown if the value does not match the type of the
frame.

The command returns the empty string.

[comment {- - -- --- ----- -------- -------------}]
[call [method scalarCmd] [cmd validate] [arg value]]

Validates the scalar [arg value] against the frame.

An error will be thrown if the value does not match the type of the
frame.

The command returns the normalized value, as per the frame's type.

[list_end][comment {-- main command list}]


[section {Mapping Instance API}]

[para] Mapping data frames provide more than just the generic API.
These additional methods should only be used after a type check:

[list_begin definitions]
[comment {- - -- --- ----- -------- -------------}]
[call [method mappingCmd] [cmd set] [arg key] [arg value]]

Extends or modifies the mapping.

After the call the [arg key] maps to the [arg value] frame.

A previously existing assignment for the [arg key] is destroyed.

The command returns the empty string.

[comment {- - -- --- ----- -------- -------------}]
[call [method mappingCmd] [cmd unset] [arg key]]

Removes the assignment identified by [arg key] from the mapping.

The associated value frame is destroyed.

The command returns the empty string.

[comment {- - -- --- ----- -------- -------------}]
[call [method mappingCmd] [cmd rename] [arg key] [arg newkey]]

Move the assignment of [arg key] to the [arg newky].

An error will be thrown if the [arg key] does not exist.

A previously existing assignment for the [arg newkey] is destroyed.

The command returns the empty string.

[list_end][comment {-- main command list}]

[include parts/feedback.inc]
[manpage_end]
